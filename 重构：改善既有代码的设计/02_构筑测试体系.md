==如果你想重构，就必须编写测试！==少许测试往往就足以带来惊人的收益。

重构时很有价值的工具，但只有重构还不行。**<u>要正确地进行重构，前提是得有一套稳固的测试集合</u>**，以帮我发现难以避免的疏漏。即便有工具可以帮我自动完成一些重构，**<u>很多重构手法依然需要通过测试集合来保障</u>**。编写**<u>优良的测试程序</u>**，可以**<u>极大提高编程速度</u>**，即使不进行重构也一样如此。

（==自测试代码的价值==）大多数程序员编写代码的时间仅占所有时间中很少的一部分，其**<u>花费在调试上的时间是最多的</u>**。修复 bug 通常是比较快的，但找出 bug 所在却是一场噩梦。当修复一个 bug 时，常常会引起另一个 bug，却在很久之后才会注意到它。那是，又要花上大把时间去定位问题。

==确保所有测试都完全自动化，让它们检查自己的测试结果==。

无需等待每次迭代结尾时再增加测试，而是只要写好一点功能，就**<u>立即添加测试代码</u>**。每天都添加一些新功能，同时也添加相应的测试。这样，只需要很少的时间来追查回归错误。

一套**<u>测试</u>**就是一个强大的 bug 侦测器，能够大大缩减查找 bug 所需的时间。

编写测试程序，意味着要写很多额外的代码。除非你却是**<u>体会</u>**到这种方法是**<u>如何提升编程速度的</u>**，否则自测试似乎就没有什么意义。

事实上，**<u>撰写测试代码的最好时机是在开始动手编码之前</u>**。当我需要添加特性时，我会先编写相应的测试代码。编写测试代码其实就是在问自己：**<u>为了添加功能，我需要实现些什么？</u>**编写测试代码还能帮我把**<u>注意力集中于接口而非实现</u>**（这永远是一件好事）。预先写好的测试代码也为编码工作安上一个明确的结束标志：一旦测试代码正常运行，工作就可以结束了。

==测试驱动开发==（Test-Driven Development, TDD），此种编程方式依赖于下面这个短循环：先编写一个（失败的）测试，编写代码使测试通过，然后进行重构以保证代码整洁。这个“**<u>测试、编码、重构</u>**”的循环应该在每个小时内都完成很多次。这种良好的节奏感可使编码工作以更加高效、有条不紊的方式开展。

『本章只是先带你**<u>走进自测试代码世界的大门</u>**，因而最好是**<u>从最简单的例子开始</u>**，也就是那些不涉及用户界面、持久性或外部服务交互的代码。这种==隔离的思路==其实在任何场景下都适用：一旦业务逻辑的部分开始变复杂，我就会把它与 UI 分离开，以便能更好地理解和测试它。』

在 Java 语言体系中，JUnit 就是一款**<u>测试框架</u>**。

**<u>一个真实的系统可能拥有数千个测试</u>**。好的测试框架应该能帮我**<u>简单快速</u>**地运行这些测试，一旦出错，我能马上看到。尽管这种反馈非常简单，但对自测试代码来说却尤为重要。工作时我会非常频繁地运行测试，要么是检验新代码的进展，要么是检查重构过程是否出错。

**<u>频繁地运行测试</u>**。对于你正在处理的代码，与其对应的测试至少每隔几分钟就要运行一次，每天至少运行一次所有的测试。

**<u>继续添加更多测试</u>**，我遵循的风格是：观察被测试类应该==做==的**<u>所有事情</u>**，然后对这个类的**<u>每个行为</u>**进行测试，包括各种可能使它发生异常的**<u>边界条件</u>**。记住：测试应该是一种**<u>风险驱动</u>**的行为，我测试的目标是希望找出现在或未来可能出现的 bug。如果尝试撰写太多测试，结果往往反而导致测试不充分。事实上，即使我只做一点点测试，也从中获益良多。测试的重点应该是那些我**<u>最担心出错的部分</u>**，这样就能从测试工作中得到最大利益。

编写**<u>未臻完善的测试</u>**并经常运行，好过对**<u>完美测试</u>**的无尽等待。

测试中的“**<u>正常路径</u>**”，指的是一切工作正常、用户使用方式也最符合规范的那种场景。同时，把测试推到这些**<u>条件的边界处</u>**也是不错的实践，这可以检查操作出错时软件的表现。==考虑可能出错的边界条件，把测试火力集中在那儿==。在这种情况下，扮演的是“程序公敌”的角色——积极思考如何破坏代码——这种思维能够提高生产力，并且很有趣。

（什么时候该停下来？）“==任何测试都不能证明一个程序没有 bug==。”但这并不影响“测试可以提高编程速度”。当测试数量达到一定程度之后，继续增加测试带来的边际效用会递减；如果试图编写太多测试，你也可能因为工作量太大而气馁，最后什么都写不成。你应该**<u>把测试集中在可能出错的地方</u>**。==观察代码，看哪儿变得复杂；观察函数，思考哪些地方可能出错==。

不要因为测试无法捕捉所有的 bug 就不写测试，因为**<u>测试的确可以捕捉到大多数 bug</u>**。

测试本书是一个**<u>很重要的话题</u>**，它既是重构所必须要的基础保障，本身也是一个有价值的工具。此前，测试更多被认为是另一个独立的（所需专业技能也较少的）团队的责任，但现在它愈发成为**<u>任何一个软件开发者所必备的技能</u>**。如今一个**<u>架构的好坏</u>**，很大程度要取决于它的**<u>可测试性</u>**，这是一个好的行业趋势。

一般情况下，我们接触到的、写的测试都属于==单元测试==，负责测试一块小的代码单元，运行足够快速。它们是自测试代码的支柱，是一个系统中占绝大多数的测试类型。同时也有其他种类的测试存在，有的专注于组件之间的集成，有的会检验软件跨越几个层级的运行结果，有的用于查找性能问题，不一而足。与编程的许多方面类似，测试也是一种**<u>迭代式的活动</u>**。

一个值得养成的好习惯是：==每当你遇到一个 bug，先写一个测试来清楚地复现它==。仅当测试通过时，才视为 bug 修完。只要测试存在一天，我就知道这个错误永远不会再复现。

一个测试集是否足够好，最好的衡量标准其实是主观的。试问自己：如果有人在代码里引入了一个缺陷，你有多大的自信它能被测试揪出来？这种信息难以被定量分析。但**<u>自测试代码的全部目标，就是要帮我们获得此种信心</u>**。

