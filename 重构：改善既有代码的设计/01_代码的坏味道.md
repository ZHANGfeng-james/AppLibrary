**<u>决定何时重构及何时停止</u>**和知道重构机制如何运转一样重要——用『代码味道』指出重构的可能性，告诉了我们一些迹象，指出：“这里有一个可以用重构解决的问题”。**<u>必须培养自己的判断力，学会判断一个类内有多少实例变量算是太大、一个函数内有多少行代码才算太长</u>**。

（==神秘命名==）**<u>整洁代码最重要的一环就是好的名字</u>**，所以我们会深思熟虑如何给函数、模块、变量和类命名，使它们能清晰地表明自己的功能和用法。但**<u>命名是编程中最难的两件事之一</u>**。**<u>如果你想不出一个好名字，说明背后很可能潜藏着更深的设计问题</u>**。为一个恼人的名字所付出的纠结，常常恩感推动我们对代码进行精简。（我当然不喜欢像读侦探小说那样，从神秘文字猜测故事情节！）

（==重复代码==）如果你在一个以上的地点看到相同的代码结构，那么可以肯定：**<u>设法将它们合而为一，程序会变得更好</u>**。一旦有重复代码存在，阅读这些重复的代码时你就必须加倍仔细，留意其间的细微的差异。==如果要修改重复代码，你必须找出所有的副本来修改==——代码有错误，需要花费代价修改所有的地方。

（==过长函数==）据我们的经验，获得最长、最好的程序，其中的函数都比较短。这些小函数的价值——==更好阐述力、更易于分享、更多的选择==——都是由小函数来支持的。**<u>让小函数易于理解的关键还是在于良好的命名</u>**。如果你能给函数起个**<u>好名字</u>**，阅读代码的人就可以通过名字了解函数的作用，根本不必去看其中写了些什么。我们应该更积极地分解函数，并遵循这样一条原则：每当感觉需要以注释来说明点什么的时候，我们就把需要说明的东西写进一个独立函数中，并以其**<u>用途（而非实现手法）</u>**命名。**<u>关键不在于函数的长度，而在于函数“做什么”和“如何做”之间的语义距离</u>**。『99%的场合里，要把函数变短，只需使用提炼函数——==找到函数中适合集中在一起的部分（此部分的凝聚点）==，将它们提炼出来形成一个新函数。』如何确定该提炼哪一段代码呢？一个很好的技巧是：==寻找注释==。它们通常能**<u>指出代码用途和实现手法之间的语义距离</u>**。如果代码前方有一行注释，就是在提醒你：可以将这段代码替换成一个函数，而且可以在注释的基础上给这个函数命名。

（==过长参数列表==）把函数所需的所有东西都以参数的形式传递进去，除此以外就只能选择全局数据，而全局数据很快就会变成邪恶的东西。**<u>过长的参数列表本身经常令人迷惑</u>**。

（==全局数据==）**<u>全局数据是最刺鼻的坏味道之一</u>**！全局数据的问题在于，从代码库的任何一个角落都可以修改它，而且没有任何机制可以探测出到底哪段代码做出了修改。一次又一次，全局数据造成了那些诡异的 bug，而问题的根源却在遥远的别处，想要找到出错的代码难于登天。全局数据最显而易见的形式就是**<u>全局变量</u>**，但**<u>类变量</u>**和**<u>单例</u>**也有这样的问题。有少量的全局数据或许无妨，但数量越多，处理的难度就会指数上升。

（==可变数据==）对数据的修改经常导致出意料的结果和难以发现的 bug。

（==发散式变化==）我们希望软件能够更容易被修改——**<u>毕竟软件本来就该是“软”的</u>**。一旦需要修改，我们希望能够跳到系统的某一点，**<u>只在该处做修改</u>**。如果**<u>某个模块</u>**经常因为不同的原因在不同的方向上发生变化，发散式变化就出现了。比如：数据库交互和金融逻辑处理是两个不同的上下文，将它们分别搬移到各自独立的模块中，能让模块变得更好：每当要对某个上下文做修改时，我们只需要理解这个上下文，而不必操心另一个。==『每次只关心一个上下文』==这一点一直很重要。在程序刚开发出来还在随着软件系统的能力不断演进时，上下文边界通常不是那么清晰。

（==霰弹式修改==）霰弹式修改类似于发散式变化，但又恰恰相反。如果每遇到某种变化，你都**<u>必须在许多不同的类内做出许多小修改</u>**，你所面临的坏味道就是霰弹式修改。

（==依恋情结==）所谓==模块化==，就是力求==将代码分出区域==，**<u>最大化区域内部的交互、最小化跨区域的交互</u>**。但有时你会发现，一个函数跟另一个模块中的函数或者数据交流格外频繁，远胜于在自己所处模块内部的交流，这就是依恋情结的典型情况。

（==数据泥团==）数据项就像小孩子，喜欢成群结队地待在一块儿。一个好的评判办法是：删除众多数据中的一项。如果这么做，其他数据有没有因而失去意义？如果它们不再有意义，这就是一个明确的信号：你应该为它们产生一个新对象。

（==基本类型偏执==）大多数编程环境都大量使用基本类型，即整数、浮点数和字符串等。一些库会引入一些小对象，如日期。但我们发现一个很有趣的现象：**<u>很多程序员不愿意创建对自己的问题域有用的基本类型</u>**，如钱、坐标、范围等。可以运用以对象取代基本类型将原本单独存在的数据值替换为对象，从而走出传统的洞窟，进入炙手可热的**<u>对象世界</u>**。

（==重复的 switch==）重复的 switch 的问题在于：每当你想增加一个选择分支时，必须**<u>找到所有的 switch</u>**，并逐一更新。这也就是为什么**<u>多态</u>**给了我们对抗这种黑暗力量的武器，使我们得到更优雅的代码库。

（==循环语句==）管道操作（如 filter 和 map）可以帮助我们更快地看清被处理的元素以及处理它们懂动作。我们可以使用**<u>管道</u>**取代循环。

（==冗赘的元素==）程序元素（如类和函数）能给代码增加结构，从而支持变化、促进复用或者哪怕只是提供更好的名字也好，但有时我们真的不需要这层额外的结构——冗赘的元素。

（==夸夸其谈通用性==）如果所有装置都会被用到，就值得那么做；如果用不到，就不值得。用不上的装置只会挡你的路，所以，把它搬开吧。言下之意：去掉程序中没有使用到的参数、结构、继承关系。

（==临时字段==）是这样的情况：类的内部某个字段仅为某种特定情况而设。这样的代码**<u>让人不易理解</u>**，因为你通常认为对象在所有时候都需要它的所有字段。

（==过长的消息链==）是这样的情况：用户向一个对戏那个请求另一个对象，然后再向后者请求另一个对象，然后再请求另一个对象......这就是消息链。采取这种方式，意味客户端代码将与查找过程中的导航结构紧密耦合。一旦对象间的关系发生任何变化，客户端就不得不做出相应修改。

（==中间人==）是这样的情况：某个类的接口有一半的函数都委托给其他类，这样就是过度运用。这时应该使用移除中间人，直接和真正负责的对象打交道。

（==内幕交易==）软件开发者喜欢在模块之间建起高墙，及其反感在模块之间大量交换数据，因为这会增加模块间的耦合。在实际情况里，一定的数据交换不可避免，但我们必须尽量减少这种情况，并**<u>把这种交换都放到明面上来</u>**。

（==过大的类==）如果想利用单个类做太多事情，其内往往就会出现太多字段。一旦如此，重复代码也就接踵而至了。和“太多实例变量”一样，类内如果有太多代码，也是代码重复、混乱并最终走向死亡的源头。最简单的解决方案是把多余的东西消弭于类内部。观察一个大类的使用者，经常能找到如何拆分类的线索。

（==异曲同工的类==）使用类的好处之一就在于可以替换：今天用这个类，未来可以换成用另一个类。但只有当两个类的接口一致时，才能做这种替换。

（==纯数据类==）所谓纯数据类是指：**<u>它们拥有一些字段，以及用于访问（读写）这些字段的函数，除此之外一无长处</u>**。这样的类只是一种不会说话的数据容器，它们几乎一定被其他类过分细琐地操控着。纯数据类常常意味着**<u>行为被放在了错误的地方</u>**。也就是说，只要把处理数据的行为从客户端搬移到纯数据类里来，就能使情况大为改观。

（==被拒绝的馈赠==）子类应该继承超类的函数和数据。但如果它们不想或不需要继承，又该怎么办呢？它们得到所有礼物，却只从中挑选几样来玩。如果子类复用了超类的行为，却又不愿意支持超类的接口，“被拒绝的遗赠”的坏味道就会变得很浓烈。

（==注释==）注释常被人当作“**<u>除臭剂</u>**”来使用，常常会有这样的情况：你看到一段代码有着长长的注释，然后发现，==这些注释之所以存在乃是因为代码很糟糕==。如果代码写得足够好，你会发现：**<u>注释已经变得多余了，因为代码已经清楚地说明了一切</u>**。『==当你感觉需要撰写注释时，请先尝试重构，试着让素有注释都变得多余。==』如果你不知道该做什么，这才是注释的良好运用时机。除了用来记述将来的打算之外，注释还可以用来标记你并无十足把握的区域。